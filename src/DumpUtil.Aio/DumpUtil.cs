// This is generated by a tool!
namespace DumpUtil
{
    #region (using)
    using System;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Web;
    using System.Xml;
    #endregion

    #region HTML

    #region HtmlWriter

    public class HtmlWriter
    {
        IndentedTextWriter _writer;

        public virtual TextWriter Writer => _writer.InnerWriter;

        internal IndentedTextWriter InnerWriter => _writer;

        internal HtmlWriter(IndentedTextWriter itw)
        {
            _writer = itw;
        }
        public HtmlWriter(bool noTabs = false, bool disableNewLines = false) : this(new StringWriter(), noTabs: noTabs, disableNewLines: disableNewLines) { }

        public HtmlWriter(TextWriter writer, bool noTabs = false, bool disableNewLines = false)
        {
            if (noTabs) _writer = new IndentedTextWriter(writer, "", disableNewLines);
            else _writer = new IndentedTextWriter(writer, tabString: "\t", disableNewLine: disableNewLines);
        }

        public override string ToString()
        {
            return _writer.InnerWriter.ToString();
        }

        public virtual void Tag(string name, Action<HtmlTag> work)
        {

            var tag = new HtmlTag(this, name);
            work(tag);
            tag.WriteEndTag();
        }

        public virtual void Head(Action<HtmlHead> work)
        {

            var tag = new HtmlHead(this);
            work(tag);
            tag.WriteEndTag();
        }

        protected virtual void TagSpecial<T>(Action<T> work)
                where T : HtmlTag
        {

            var tag = (T)Activator.CreateInstance(typeof(T), new object[] { this });
            work(tag);
            tag.WriteEndTag();
        }

        public void Table(Action<HtmlTable> table)
        {
            TagSpecial(table);
        }


        public virtual void WriteRaw(string rawText)
        {
            _writer.Write(rawText);
        }

        public virtual void WriteLineRaw(string rawText)
        {
            _writer.WriteLine(rawText);
        }

        public void WriteString(string str, bool asPre = false)
        {
            if (asPre) WriteRaw("<pre>");
            WriteRaw(HttpUtility.HtmlEncode(str));
            if (asPre) WriteRaw("</pre>");
        }

        public void WriteDiv(Action<HtmlTag> act) => Tag("div", act);
        public void WriteSpan(Action<HtmlTag> act) => Tag("span", act);


        void STag(string name, bool withIndent = true)
        {
            //this forces the indenter to not auto indent the actual tag
            _writer.Write("");
            if (withIndent)
            {
                _writer.Indent++;
            }
            _writer.WriteLine($"<{name}>");
        }

        void ETag(string name, bool withIndent = true)
        {
            if (withIndent)
            {
                _writer.Indent--;
            }
            _writer.WriteLine($"</{name}>");
        }

        public void HtmlOpen() => STag("html", false);
        public void HtmlClose() => ETag("html", false);


        public void BodyOpen() => STag("body");
        public void BodyClose() => ETag("body");


        public void WriteJavascript(Action<JavaScriptTextWriter> act)
        {
            Tag("script", s =>
            {
                s.NewLineAfterSTag = false;
                s.WriteSTagEnd();
                var js = new JavaScriptTextWriter(s.Writer);
                js.WriteLine();
                act(js);

                s.WriteLineRaw("");
            });
        }

    }

    #endregion

    #region HtmlTag

    public class HtmlTag : HtmlWriter
    {
        public override TextWriter Writer
        {
            get
            {
                return InnerWriter.InnerWriter;
            }
        }

        public bool NewLineAfterSTag { get; set; } = true;

        string _name;
        public bool EndTagWritten { get; private set; }
        public bool STagEndWritten { get; private set; }

        internal HtmlTag(HtmlWriter writer, string name) : base(writer.InnerWriter)
        {
            _name = name;

            InnerWriter.Write($"<{name}");
        }

        public void WriteEndTag()
        {
            if (EndTagWritten) return;
            WriteSTagEnd();
            InnerWriter.Indent--;
            InnerWriter.WriteLine($"</{_name}>");
            EndTagWritten = true;
        }

        public void WriteSTagEnd()
        {
            if (STagEndWritten) return;
            InnerWriter.Write("");
            InnerWriter.Indent++;

            if (NewLineAfterSTag) InnerWriter.WriteLine(">");
            else InnerWriter.Write(">");

            STagEndWritten = true;
        }

        public override void Head(Action<HtmlHead> work)
        {
            throw new Exception("Head cannot exist in tag");
        }

        public override void Tag(string name, Action<HtmlTag> work)
        {
            WriteSTagEnd();
            base.Tag(name, work);
        }

        public override void WriteRaw(string rawText)
        {
            WriteSTagEnd();
            base.WriteRaw(rawText);
        }

        public override void WriteLineRaw(string rawText)
        {
            WriteSTagEnd();
            base.WriteLineRaw(rawText);
        }

        protected override void TagSpecial<T>(Action<T> work)
        {
            WriteSTagEnd();
            base.TagSpecial(work);
        }

        public void Attribute(string name, string value)
        {
            if (STagEndWritten) throw new Exception();

            Writer.Write($" {name}=\"{HttpUtility.HtmlAttributeEncode(value)}\"");
        }
    }

    #endregion

    #region HtmlHead



    public class HtmlHead : HtmlTag
    {

        public HtmlHead(HtmlWriter writer) : base(writer, "head")
        {

        }

        public void Title(string str)
        {
            Tag("title", t =>
            {
                t.NewLineAfterSTag = false;
                t.WriteRaw(str);
            });
        }
    }

    public class HtmlTable : HtmlTag
    {
        public HtmlTable(HtmlWriter writer) : base(writer, "table")
        {

        }

        public void Row(Action<HtmlRow> act)
        {
            TagSpecial(act);
        }
    }

    public class HtmlRow : HtmlTag
    {
        public HtmlRow(HtmlWriter writer) : base(writer, "tr")
        {

        }


        public void Column(string text)
        {
            Tag("td", td =>
            {
                td.NewLineAfterSTag = false;
                if (string.IsNullOrWhiteSpace(text))
                {
                    td.WriteRaw(" ");
                    return;
                }
                td.WriteRaw(text);
            });
        }
    }


    #endregion

    #region JavaScriptTextWriter


    public sealed class JavaScriptTextWriter : TextWriter
    {
        private TextWriter _writer;

        public override Encoding Encoding
        {
            get { return _writer.Encoding; }
        }

        public JavaScriptTextWriter(TextWriter writer)
        {
            _writer = writer;
        }

        public override void Write(string value)
        {
            _writer.Write(value);
        }

        public override void Write(char value)
        {
            _writer.Write(value);
        }


        public void WriteJson(Action<JsonTextWriter> act)
        {
            JsonTextWriter jtw = new JsonTextWriter(_writer);

            act(jtw);
        }

        public void Semi() { WriteLine(";"); }
    }

    #endregion

    #region JsonTextWriter

    /// <summary>
    /// Represents a writer that provides a fast, non-cached, forward-only 
    /// way of generating streams or files containing JSON Text according
    /// to the grammar rules laid out in <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>.
    /// </summary>
    /// <remarks>
    /// https://github.com/mikefrey/ELMAH/blob/master/src/Elmah/JsonTextWriter.cs
    /// </remarks>
    public sealed class JsonTextWriter
    {
        private readonly TextWriter _writer;
        private readonly int[] _counters;
        private readonly char[] _terminators;
        private int _depth;
        private string _memberName;

        public JsonTextWriter(TextWriter writer)
        {
            //Debug.Assert(writer != null);
            _writer = writer;
            const int levels = 10 + /* root */ 1;
            _counters = new int[levels];
            _terminators = new char[levels];
        }

        public int Depth
        {
            get { return _depth; }
        }

        private int ItemCount
        {
            get { return _counters[Depth]; }
            set { _counters[Depth] = value; }
        }

        private char Terminator
        {
            get { return _terminators[Depth]; }
            set { _terminators[Depth] = value; }
        }

        public JsonTextWriter Object()
        {
            return StartStructured("{", "}");
        }

        public JsonTextWriter EndObject()
        {
            return Pop();
        }

        public JsonTextWriter Array()
        {
            return StartStructured("[", "]");
        }

        public JsonTextWriter EndArray()
        {
            return Pop();
        }

        public JsonTextWriter Pop()
        {
            return EndStructured();
        }

        public JsonTextWriter Member(string name)
        {
            if (name == null) throw new ArgumentNullException("name");
            if (name.Length == 0) throw new ArgumentException(null, "name");
            if (_memberName != null) throw new InvalidOperationException("Missing member value.");
            _memberName = name;
            return this;
        }

        private JsonTextWriter Write(string text)
        {
            return WriteImpl(text, /* raw */ false);
        }

        private JsonTextWriter WriteEnquoted(string text)
        {
            return WriteImpl(text, /* raw */ true);
        }

        private JsonTextWriter WriteImpl(string text, bool raw)
        {
            //Debug.Assert(raw || (text != null && text.Length > 0));

            if (Depth == 0 && (text.Length > 1 || (text[0] != '{' && text[0] != '[')))
                throw new InvalidOperationException();

            TextWriter writer = _writer;

            if (ItemCount > 0)
                writer.Write(',');

            string name = _memberName;
            _memberName = null;

            if (name != null)
            {
                writer.Write(' ');
                Enquote(name, writer);
                writer.Write(':');
            }

            if (Depth > 0)
                writer.Write(' ');

            if (raw)
                Enquote(text, writer);
            else
                writer.Write(text);

            ItemCount = ItemCount + 1;

            return this;
        }

        public JsonTextWriter Number(int value)
        {
            return Write(value.ToString(CultureInfo.InvariantCulture));
        }

        public JsonTextWriter String(string str)
        {
            return str == null ? Null() : WriteEnquoted(str);
        }

        public JsonTextWriter Null()
        {
            return Write("null");
        }

        public JsonTextWriter Boolean(bool value)
        {
            return Write(value ? "true" : "false");
        }

        private static readonly DateTime _epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);


        public JsonTextWriter Number(DateTime time)
        {
            double seconds = time.ToUniversalTime().Subtract(_epoch).TotalSeconds;
            return Write(seconds.ToString(CultureInfo.InvariantCulture));
        }

        public JsonTextWriter String(DateTime time)
        {
            string xmlTime;

            xmlTime = XmlConvert.ToString(time, XmlDateTimeSerializationMode.Utc);

            return String(xmlTime);
        }

        private JsonTextWriter StartStructured(string start, string end)
        {
            if (Depth + 1 == _counters.Length)
                throw new Exception();

            Write(start);
            _depth++;
            Terminator = end[0];
            return this;
        }

        private JsonTextWriter EndStructured()
        {
            if (Depth - 1 < 0)
                throw new Exception();

            _writer.Write(' ');
            _writer.Write(Terminator);
            ItemCount = 0;
            _depth--;
            return this;
        }

        static string NullString(string s)
        {
            return s == null ? string.Empty : s;
        }

        private static void Enquote(string s, TextWriter writer)
        {
            //Debug.Assert(writer != null);

            int length = NullString(s).Length;

            writer.Write('"');

            char last;
            char ch = '\0';

            for (int index = 0; index < length; index++)
            {
                last = ch;
                ch = s[index];

                switch (ch)
                {
                    case '\\':
                    case '"':
                        {
                            writer.Write('\\');
                            writer.Write(ch);
                            break;
                        }

                    case '/':
                        {
                            if (last == '<')
                                writer.Write('\\');
                            writer.Write(ch);
                            break;
                        }

                    case '\b': writer.Write("\\b"); break;
                    case '\t': writer.Write("\\t"); break;
                    case '\n': writer.Write("\\n"); break;
                    case '\f': writer.Write("\\f"); break;
                    case '\r': writer.Write("\\r"); break;

                    default:
                        {
                            if (ch < ' ')
                            {
                                writer.Write("\\u");
                                writer.Write(((int)ch).ToString("x4", CultureInfo.InvariantCulture));
                            }
                            else
                            {
                                writer.Write(ch);
                            }

                            break;
                        }
                }
            }

            writer.Write('"');
        }
    }

    #endregion

    #region IndentedTextWriter

    /// <summary>
    ///     The same as <see cref="System.CodeDom.Compiler.IndentedTextWriter" /> but works in partial trust.
    /// </summary>
    public class IndentedTextWriter : TextWriter
    {
        /// <summary>
        ///     Specifies the default tab string. This field is constant.
        /// </summary>
        public const string DefaultTabString = "    ";

        private readonly TextWriter _writer;
        private int _indentLevel;
        private bool _tabsPending;
        private readonly string _tabString;


        /// <summary>
        ///     Gets the encoding for the text writer to use.
        /// </summary>
        /// <returns>
        ///     An <see cref="T:System.Text.Encoding" /> that indicates the encoding for the text writer to use.
        /// </returns>
        public override Encoding Encoding
        {
            get { return _writer.Encoding; }
        }

        /// <summary>
        ///     Gets or sets the new line character to use.
        /// </summary>
        /// <returns> The new line character to use. </returns>
        public override string NewLine
        {
            get { return _writer.NewLine; }
            set { _writer.NewLine = value; }
        }

        /// <summary>
        ///     Gets or sets the number of spaces to indent.
        /// </summary>
        /// <returns> The number of spaces to indent. </returns>
        public int Indent
        {
            get { return _indentLevel; }
            set
            {
                if (value < 0)
                {
                    value = 0;
                }
                _indentLevel = value;
            }
        }

        /// <summary>
        ///     Gets the <see cref="T:System.IO.TextWriter" /> to use.
        /// </summary>
        /// <returns>
        ///     The <see cref="T:System.IO.TextWriter" /> to use.
        /// </returns>
        public TextWriter InnerWriter
        {
            get { return _writer; }
        }

        /// <summary>
        ///     Initializes a new instance of the IndentedTextWriter class using the specified text writer and default tab string.
        /// </summary>
        /// <param name="writer">
        ///     The <see cref="T:System.IO.TextWriter" /> to use for output.
        /// </param>
        public IndentedTextWriter(TextWriter writer)
            : this(writer, DefaultTabString, false)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the IndentedTextWriter class using the specified text writer and tab string.
        /// </summary>
        /// <param name="writer">
        ///     The <see cref="T:System.IO.TextWriter" /> to use for output.
        /// </param>
        /// <param name="tabString"> The tab string to use for indentation. </param>
        public IndentedTextWriter(TextWriter writer, string tabString, bool disableNewLine)
            : base(CultureInfo.InvariantCulture)
        {
            _writer = writer;
            _tabString = tabString;
            _indentLevel = 0;
            _tabsPending = false;
            if (disableNewLine) _writer.NewLine = " ";
        }

        /// <summary>
        ///     Closes the document being written to.
        /// </summary>
        public override void Close()
        {
            _writer.Close();
        }

        /// <summary>
        ///     Flushes the stream.
        /// </summary>
        public override void Flush()
        {
            _writer.Flush();
        }

        /// <summary>
        ///     Outputs the tab string once for each level of indentation according to the
        ///     <see
        ///         cref="P:System.CodeDom.Compiler.IndentedTextWriter.Indent" />
        ///     property.
        /// </summary>
        protected virtual void OutputTabs()
        {
            if (_tabString == "") return;

            if (!_tabsPending)
            {
                return;
            }
            for (var index = 0; index < _indentLevel; ++index)
            {
                _writer.Write(_tabString);
            }
            _tabsPending = false;
        }

        /// <summary>
        ///     Writes the specified string to the text stream.
        /// </summary>
        /// <param name="value"> The string to write. </param>
        public override void Write(string value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes the text representation of a Boolean value to the text stream.
        /// </summary>
        /// <param name="value"> The Boolean value to write. </param>
        public override void Write(bool value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes a character to the text stream.
        /// </summary>
        /// <param name="value"> The character to write. </param>
        public override void Write(char value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes a character array to the text stream.
        /// </summary>
        /// <param name="buffer"> The character array to write. </param>
        public override void Write(char[] buffer)
        {
            OutputTabs();
            _writer.Write(buffer);
        }

        /// <summary>
        ///     Writes a subarray of characters to the text stream.
        /// </summary>
        /// <param name="buffer"> The character array to write data from. </param>
        /// <param name="index"> Starting index in the buffer. </param>
        /// <param name="count"> The number of characters to write. </param>
        public override void Write(char[] buffer, int index, int count)
        {
            OutputTabs();
            _writer.Write(buffer, index, count);
        }

        /// <summary>
        ///     Writes the text representation of a Double to the text stream.
        /// </summary>
        /// <param name="value"> The double to write. </param>
        public override void Write(double value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes the text representation of a Single to the text stream.
        /// </summary>
        /// <param name="value"> The single to write. </param>
        public override void Write(float value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes the text representation of an integer to the text stream.
        /// </summary>
        /// <param name="value"> The integer to write. </param>
        public override void Write(int value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes the text representation of an 8-byte integer to the text stream.
        /// </summary>
        /// <param name="value"> The 8-byte integer to write. </param>
        public override void Write(long value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes the text representation of an object to the text stream.
        /// </summary>
        /// <param name="value"> The object to write. </param>
        public override void Write(object value)
        {
            OutputTabs();
            _writer.Write(value);
        }

        /// <summary>
        ///     Writes out a formatted string, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string. </param>
        /// <param name="arg0"> The object to write into the formatted string. </param>
        public override void Write(string format, object arg0)
        {
            OutputTabs();
            _writer.Write(format, arg0);
        }

        /// <summary>
        ///     Writes out a formatted string, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string to use. </param>
        /// <param name="arg0"> The first object to write into the formatted string. </param>
        /// <param name="arg1"> The second object to write into the formatted string. </param>
        public override void Write(string format, object arg0, object arg1)
        {
            OutputTabs();
            _writer.Write(format, arg0, arg1);
        }

        /// <summary>
        ///     Writes out a formatted string, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string to use. </param>
        /// <param name="arg"> The argument array to output. </param>
        public override void Write(string format, params object[] arg)
        {
            OutputTabs();
            _writer.Write(format, arg);
        }

        /// <summary>
        ///     Writes the specified string to a line without tabs.
        /// </summary>
        /// <param name="value"> The string to write. </param>
        public void WriteLineNoTabs(string value)
        {
            _writer.WriteLine(value);
        }

        /// <summary>
        ///     Writes the specified string, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The string to write. </param>
        public override void WriteLine(string value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes a line terminator.
        /// </summary>
        public override void WriteLine()
        {
            OutputTabs();
            _writer.WriteLine();
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of a Boolean, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The Boolean to write. </param>
        public override void WriteLine(bool value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes a character, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The character to write. </param>
        public override void WriteLine(char value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes a character array, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="buffer"> The character array to write. </param>
        public override void WriteLine(char[] buffer)
        {
            OutputTabs();
            _writer.WriteLine(buffer);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes a subarray of characters, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="buffer"> The character array to write data from. </param>
        /// <param name="index"> Starting index in the buffer. </param>
        /// <param name="count"> The number of characters to write. </param>
        public override void WriteLine(char[] buffer, int index, int count)
        {
            OutputTabs();
            _writer.WriteLine(buffer, index, count);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of a Double, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The double to write. </param>
        public override void WriteLine(double value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of a Single, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The single to write. </param>
        public override void WriteLine(float value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of an integer, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The integer to write. </param>
        public override void WriteLine(int value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of an 8-byte integer, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The 8-byte integer to write. </param>
        public override void WriteLine(long value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of an object, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> The object to write. </param>
        public override void WriteLine(object value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes out a formatted string, followed by a line terminator, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string. </param>
        /// <param name="arg0"> The object to write into the formatted string. </param>
        public override void WriteLine(string format, object arg0)
        {
            OutputTabs();
            _writer.WriteLine(format, arg0);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes out a formatted string, followed by a line terminator, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string to use. </param>
        /// <param name="arg0"> The first object to write into the formatted string. </param>
        /// <param name="arg1"> The second object to write into the formatted string. </param>
        public override void WriteLine(string format, object arg0, object arg1)
        {
            OutputTabs();
            _writer.WriteLine(format, arg0, arg1);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes out a formatted string, followed by a line terminator, using the same semantics as specified.
        /// </summary>
        /// <param name="format"> The formatting string to use. </param>
        /// <param name="arg"> The argument array to output. </param>
        public override void WriteLine(string format, params object[] arg)
        {
            OutputTabs();
            _writer.WriteLine(format, arg);
            _tabsPending = true;
        }

        /// <summary>
        ///     Writes the text representation of a UInt32, followed by a line terminator, to the text stream.
        /// </summary>
        /// <param name="value"> A UInt32 to output. </param>
        public override void WriteLine(uint value)
        {
            OutputTabs();
            _writer.WriteLine(value);
            _tabsPending = true;
        }
    }


    #endregion

    #endregion
}


namespace DumpUtil
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;


    public class DumpHtmlWriter : HtmlWriter
    {

        public void WriteStyles()
        {
            DumpManager.WriteStyle(this);
        }

        public void WriteJavaScript()
        {
            DumpManager.WriteScript(this);
        }

        public void Dump(object obj)
        {
            DumpManager.Dump(obj, this);
            WriteRaw("<br />");
        }
    }
}

namespace DumpUtil
{
    #region (using)
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.Serialization;
    #endregion

    #region Dump


    #region RefDictionary

    sealed class RefDictionary
    {
        readonly HashSet<long> _set = new HashSet<long>();
        readonly ObjectIDGenerator _gen = new ObjectIDGenerator();

        public bool Add(object o)
        {
            if (o == null) return true;
            if (o.GetType().IsClass == false) return true;

            bool firstTime;
            var x = _gen.GetId(o, out firstTime);
            return _set.Add(x);

        }

        public long? GetID(object o)
        {
            if (o == null) return null;
            if (o.GetType().IsClass == false) return null;

            bool firstTime;
            return _gen.GetId(o, out firstTime);
        }
    }

    #endregion


    #region DumpState

    sealed class DumpState
    {
        public bool InList { get; }
        public int Level { get; }
        public DumpState() { }
        private DumpState(int level, bool inList)
        {
            InList = inList;
            Level = level;
        }
        public DumpState BumpLevel()
        {
            return new DumpState(level: Level + 1, inList: InList);
        }
        public DumpState AsList(bool list = true)
        {
            return new DumpState(level: Level, inList: list);
        }
    }

    #endregion

    public static class DumpManager
    {

        static readonly List<DumpType> Types;

        static DumpManager()
        {
            Types = GetEnumerableOfType<DumpType>().OrderByDescending(x => x.Priority).ToList();
        }

        static IEnumerable<T> GetEnumerableOfType<T>(params object[] constructorArgs)
            where T : class
        {
            var q = Assembly.GetAssembly(typeof(T))
                            .GetTypes()
                            .Where(myType => myType.IsClass && !myType.IsAbstract && myType.IsSubclassOf(typeof(T)));
            return q.Select(type => (T)Activator.CreateInstance(type, constructorArgs))
                    .ToList();
        }

        public static void WriteStyle(HtmlWriter writer)
        {

            writer.Tag("style", s =>
            {
                s.NewLineAfterSTag = false;
                s.WriteRaw(Res.Style);
            });
        }

        public static void WriteScript(HtmlWriter writer)
        {
            writer.WriteRaw("<script>");

         //   writer.WriteRaw(System.Text.Encoding.Default.GetString(Res.Javascript));
            writer.WriteRaw(Res.Script);

            writer.WriteRaw("</script>");
        }

        internal static void Dump(object o, Type oType, HtmlWriter writer, DumpState state, RefDictionary refDict)
        {
            if (state == null) { state = new DumpState(); }
            else
            {
                state = state.BumpLevel();
            }



            if (refDict == null) refDict = new RefDictionary();

            if (refDict.Add(o) == false)
            {
                writer.Tag("span", t =>
                {
                    t.Attribute("class", "goto");
                    t.Attribute("data-goto", refDict.GetID(o).ToString());
                    t.WriteString("<>");
                });
                return;
            }

            if (o == null)
            {
                writer.WriteString("null");
                return;
            }



            var dt = GetDumpType(oType);
            if (dt == null)
            {
                writer.WriteSpan(s => s.WriteString($"{oType.FullName} NOT HANDLED"));
                return;
            }


            if (dt.IgnoreDeep == false)
            {
                if (state.Level >= 4)
                {
                    writer.WriteString("TOO DEEP");
                    return;
                }
            }
            dt.Write(o, writer, state, refDict);
        }

        public static void Dump(object o, HtmlWriter writer)
        {
            var oType = o.GetType();
            Dump(o, oType, writer, null, null);
        }

        public static string DumpToHtml(object o, string title = "Dump")
        {
            HtmlWriter writer = new HtmlWriter(false, false);
            writer.HtmlOpen();
            writer.Head(h =>
            {
                h.Title(title);
                h.WriteRaw("<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />");
                WriteStyle(h);
            });

            writer.BodyOpen();


            Dump(o, writer);

            WriteScript(writer);

            writer.BodyClose();
            writer.HtmlClose();

            var html = writer.Writer.ToString();

            return html;
        }

        static DumpType GetDumpType(Type t)
        {


            foreach (var dt in Types)
            {
                if (dt.ValidTypes.Contains(t))
                {
                    return dt;
                }

                if (dt.AcceptsType(t))
                {
                    return dt;
                }
            }

            return null;
        }
    }

    #region DumpType

    abstract class DumpType
    {
        public virtual int Priority { get { return 1; } }

        public virtual bool IgnoreDeep { get { return false; } }

        public virtual Type[] ValidTypes
        {
            get
            {
                return new Type[] { };
            }
        }

        public virtual bool AcceptsType(Type t)
        {
            return false;
        }

        public abstract void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict);


        protected void SetID(RefDictionary dict, HtmlWriter wri, object o)
        {
            (wri as HtmlTag)?.Attribute("data-id", dict.GetID(o).ToString());
        }
    }

    #endregion

    #region SingleDumpType`1
    abstract class SingleDumpType<T> : DumpType
    {
        public sealed override int Priority { get { return 5; } }

        public sealed override Type[] ValidTypes
        {
            get { return new[] { typeof(T) }; }
        }

        public sealed override bool AcceptsType(Type t)
        {
            return base.AcceptsType(t);
        }

        public sealed override void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            Write((T)o, tag, state, refDict);
        }

        protected abstract void Write(T o, HtmlWriter tag, DumpState state, RefDictionary refDict);

    }
    #endregion

    #region string
    sealed class StringDump : SingleDumpType<string>
    {
        protected override void Write(string o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            if (o.Contains(Environment.NewLine))
            {
                tag.Tag("pre", p =>
                {
                    p.Attribute("class", "str tg");
                    p.NewLineAfterSTag = false;
                    p.WriteString(o);
                });
            }
            else
            {
                tag.WriteSpan(s =>
                {
                    s.NewLineAfterSTag = false;
                    s.WriteString(o);
                });
            }
        }

        public override bool IgnoreDeep
        {
            get
            {
                return true;
            }
        }
    }

    #endregion

    #region ToStringDump
    sealed class ToStringDump : DumpType
    {
        static Type[] Types = new[] {   typeof(byte),typeof(char),typeof(decimal),typeof(double),typeof(float),typeof(int),typeof(long),
                                        typeof(sbyte),typeof(short),typeof(string),typeof(uint),typeof(ulong)};
        public override bool IgnoreDeep { get { return true; } }

        public override Type[] ValidTypes { get { return Types; } }

        public override void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            tag.WriteSpan(span =>
            {
                span.Attribute("title", o.GetType().FullName);
                span.WriteString(o.ToString());
            });
        }
    }

    #endregion

    #region bool
    sealed class BoolDump : SingleDumpType<bool>
    {
        protected override void Write(bool o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            var str = (bool)o ? "true" : "false";
            tag.WriteSpan(s =>
            {
                s.NewLineAfterSTag = false;
                s.Attribute("class", "b");
                //s.Attribute("style", "color:blue;");
                s.WriteString(str);
            });
        }

        public override bool IgnoreDeep { get { return true; } }
    }
    #endregion

    #region IEnumerable (ListDump)
    sealed class ListDump : DumpType
    {
        public override int Priority
        {
            get
            {
                return 2;
            }
        }

        public override bool AcceptsType(Type t)
        {
            if (t.GetInterfaces().Select(x => x.IsGenericType ? x.GetGenericTypeDefinition() : x).Contains(typeof(System.Collections.IEnumerable)))
            {
                return true;
            }

            return false;
        }

        public override void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            state = state.AsList();

            var e = (o as IEnumerable).GetEnumerator();

            tag.Table(ul =>
            {
                int idx = 0;
                while (e.MoveNext())
                {
                    ul.Row(r =>
                    {
                        r.Tag("th", th => th.WriteString(idx.ToString()));
                        r.Tag("td", td =>
                        {
                            DumpManager.Dump(e.Current, e.Current.GetType(), td, state, refDict);

                        });
                    });
                    idx++;
                    if (idx > 100)
                    {
                        ul.Row(r =>
                        {
                            r.Tag("td", td =>
                            {
                                td.Attribute("colspan", "2");
                                td.WriteString("...");
                            });
                        });
                        return;
                    }
                }
            });


        }
    }
    #endregion

    #region Default (ObjectDump)
    sealed class ObjectDump : DumpType
    {
        public override bool AcceptsType(Type t)
        {
            return true;
        }

        public override void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
            //if (tag is HtmlTag && o != null)
            //{
            //    (tag as HtmlTag).Attribute("data-id", refDict.GetID(o).ToString());
            //}

            var type = o.GetType();

            WriteSingleObject(o, tag, type, state, refDict);

        }

        private void WriteSingleObject(object o, HtmlWriter tag, Type type, DumpState state, RefDictionary refDict)
        {
            tag.Table(table =>
            {
                SetID(refDict, table, o);
                table.Row(r =>
                {
                    r.Tag("th", th =>
                    {
                        th.Attribute("colspan", "2");
                        th.Attribute("class", "o");
                        th.Tag("span", s => s.WriteString(type.Namespace));
                        th.Tag("span", s =>
                        {
                            s.NewLineAfterSTag = false;
                            s.Attribute("class", "type");
                            s.WriteString(type.Name);
                        });
                        //    th.WriteString(type.FullName);
                    });
                });
                table.Row(r =>
                {
                    r.Tag("td", th =>
                    {
                        th.Attribute("colspan", "2");
                        th.WriteString(o.ToString());
                    });
                });

                foreach (var p in type.GetProperties())
                {
                    NewMethod(o, state, refDict, table, p);
                }

                foreach (var p in type.GetFields())
                {
                    NewMethod2(o, state, refDict, table, p);
                }
            });
        }

        private static void NewMethod2(object o, DumpState state, RefDictionary refDict, HtmlTable table, FieldInfo p)
        {
            table.Row(r =>
            {
                r.Tag("th", th =>
                {
                    th.NewLineAfterSTag = false;
                    th.Attribute("title", p.FieldType.FullName.ToString());
                    th.WriteString(p.Name);
                });

                r.Tag("td", td =>
                {
                    object val = null;
                    try
                    {
                        val = p.GetValue(o);
                    }
                    catch (Exception ex)
                    {
                        td.Attribute("style", "background:pink");
                        td.Tag("pre", pr =>
                        {
                            pr.NewLineAfterSTag = false;
                            pr.Attribute("class", "tg");
                            pr.WriteString(ex.ToString());
                        });
                        return;
                    }

                    DumpManager.Dump(val, p.FieldType, td, state, refDict);


                });
            });
        }

        private static void NewMethod(object o, DumpState state, RefDictionary refDict, HtmlTable table, PropertyInfo p)
        {
            table.Row(r =>
            {
                r.Tag("th", th =>
                {
                    th.NewLineAfterSTag = false;
                    th.Attribute("title", p.PropertyType.FullName.ToString());
                    th.WriteString(p.Name);
                });

                r.Tag("td", td =>
                {
                    object val = null;
                    try
                    {
                        val = p.GetValue(o);
                    }
                    catch (Exception ex)
                    {
                        td.Attribute("style", "background:pink");
                        td.Tag("pre", pr =>
                        {
                            pr.NewLineAfterSTag = false;
                            pr.Attribute("class", "tg");
                            pr.WriteString(ex.ToString());
                        });
                        return;
                    }

                    DumpManager.Dump(val, p.PropertyType, td, state, refDict);


                });
            });
        }
    }
    #endregion

    #endregion

    #region MiscUtil
    public static class DumpUtilites
    {
        /// <summary>
        /// Compares to strings char by char. Useful for linqpad
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static string StringCompareHtml(string a, string b)
        {
            if (a == null && b == null) return "";
            var max = new[] { a, b }.Where(x => x != null).Max(x => x.Length);
            bool bIsNull = false;
            if (a == null) a = new string('\0', max);
            if (b == null)
            {
                bIsNull = true;
                b = new string('\0', max);
            }

            a = GetFullLengthString(a, max);

            HtmlWriter hw = new HtmlWriter();

            hw.Table(t =>
            {
                t.Row(r =>
                {
                    for (int i = 0; i < max; i++)
                        r.Tag("th", h => h.WriteRaw(i.ToString()));
                });

                t.Row(r =>
                {
                    foreach (var c in a)
                    {
                        r.Tag("td", td =>
                        {
                            StringCompareHtml_td(td, c);
                        });
                    }
                });

                if (bIsNull) return;
                t.Row(r =>
                {
                    var idx = 0;
                    foreach (var c in b)
                    {
                        r.Tag("td", td =>
                        {
                            td.NewLineAfterSTag = false;
                            try
                            {
                                if (a[idx] != c)
                                {
                                    td.Attribute("style", "background:pink;");
                                }
                            }
                            catch
                            {

                            }
                            StringCompareHtml_td(td, c);

                        });

                        idx++;

                    }

                });


            });

            return hw.Writer.ToString();
        }

        private static void StringCompareHtml_td(HtmlTag td, char c)
        {
            if (c == (char)0)
            {
                td.Tag("span", span =>
                {
                    span.Attribute("style", "color:gray");
                    span.WriteString("\\0");

                });
            }
            else
            {
                td.WriteString(c.ToString());
            }
        }

        /// <summary>
        /// pads '\0' at the end
        /// </summary>
        /// <param name="a"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        private static string GetFullLengthString(string a, int max)
        {
            if (a.Length != max)
            {
                var chars = new char[max];
                for (int i = 0; i < chars.Length; i++)
                {
                    if (a.Length > i) chars[i] = a[i];
                    else chars[i] = (char)0;
                }

                a = new string(chars);
            }

            return a;
        }
    }
    #endregion
}


namespace DumpUtil
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;


    abstract class BaseEnumDumpType:DumpType
    {
        
    }

    class EnumDumpType : BaseEnumDumpType
    {

        public override int Priority
        {
            get
            {
                return 5;
            }
        }

        public override bool AcceptsType(Type t)
        {
            return t.IsEnum;
        }

        public override void Write(object o, HtmlWriter tag, DumpState state, RefDictionary refDict)
        {
          var val =  o.ToString();
            tag.Tag("kbd", t =>
            {
                t.NewLineAfterSTag = false;
                t.WriteString(val);
            });
        }
    }


    //class FlagEnumDumpType: BaseEnumDumpType
    //{

    //}
}

namespace DumpUtil
{
    static class Res
    {
        public static byte[] Javascript = new byte[] { 10, 118, 97, 114, 32, 95, 61, 123, 114, 101, 109, 111, 118, 101, 69, 108, 101, 109, 101, 110, 116, 58, 102, 117, 110, 99, 116, 105, 111, 110, 40, 101, 108, 101, 109, 101, 110, 116, 41, 123, 101, 108, 101, 109, 101, 110, 116, 38, 38, 101, 108, 101, 109, 101, 110, 116, 46, 112, 97, 114, 101, 110, 116, 78, 111, 100, 101, 38, 38, 101, 108, 101, 109, 101, 110, 116, 46, 112, 97, 114, 101, 110, 116, 78, 111, 100, 101, 46, 114, 101, 109, 111, 118, 101, 67, 104, 105, 108, 100, 40, 101, 108, 101, 109, 101, 110, 116, 41, 59, 125, 44, 115, 99, 114, 111, 108, 108, 84, 111, 58, 102, 117, 110, 99, 116, 105, 111, 110, 32, 115, 99, 114, 111, 108, 108, 84, 111, 40, 101, 108, 101, 41, 123, 101, 108, 101, 46, 115, 99, 114, 111, 108, 108, 73, 110, 116, 111, 86, 105, 101, 119, 40, 41, 59, 125, 44, 102, 111, 114, 101, 97, 99, 104, 83, 101, 108, 101, 99, 116, 111, 114, 58, 102, 117, 110, 99, 116, 105, 111, 110, 32, 102, 111, 114, 101, 97, 99, 104, 83, 101, 108, 101, 99, 116, 111, 114, 40, 115, 101, 108, 44, 97, 99, 116, 41, 123, 118, 97, 114, 32, 110, 108, 61, 100, 111, 99, 117, 109, 101, 110, 116, 46, 113, 117, 101, 114, 121, 83, 101, 108, 101, 99, 116, 111, 114, 65, 108, 108, 40, 115, 101, 108, 41, 59, 102, 111, 114, 40, 118, 97, 114, 32, 105, 61, 48, 59, 105, 60, 110, 108, 46, 108, 101, 110, 103, 116, 104, 59, 43, 43, 105, 41, 123, 118, 97, 114, 32, 105, 116, 101, 109, 61, 110, 108, 91, 105, 93, 59, 97, 99, 116, 40, 105, 116, 101, 109, 41, 59, 125, 125, 125, 59, 102, 117, 110, 99, 116, 105, 111, 110, 32, 104, 105, 103, 104, 108, 105, 103, 104, 116, 73, 100, 40, 105, 100, 41, 123, 118, 97, 114, 32, 114, 101, 100, 115, 61, 100, 111, 99, 117, 109, 101, 110, 116, 46, 113, 117, 101, 114, 121, 83, 101, 108, 101, 99, 116, 111, 114, 65, 108, 108, 40, 39, 46, 114, 101, 100, 45, 98, 111, 114, 100, 101, 114, 39, 41, 59, 102, 111, 114, 40, 118, 97, 114, 32, 105, 61, 114, 101, 100, 115, 46, 108, 101, 110, 103, 116, 104, 45, 49, 59, 105, 62, 61, 48, 59, 105, 45, 45, 41, 123, 118, 97, 114, 32, 114, 61, 114, 101, 100, 115, 91, 105, 93, 59, 114, 46, 99, 108, 97, 115, 115, 76, 105, 115, 116, 46, 114, 101, 109, 111, 118, 101, 40, 39, 114, 101, 100, 45, 98, 111, 114, 100, 101, 114, 39, 41, 59, 125, 59, 118, 97, 114, 32, 105, 116, 101, 109, 115, 61, 100, 111, 99, 117, 109, 101, 110, 116, 46, 113, 117, 101, 114, 121, 83, 101, 108, 101, 99, 116, 111, 114, 65, 108, 108, 40, 39, 91, 100, 97, 116, 97, 45, 105, 100, 61, 34, 39, 43, 105, 100, 43, 39, 34, 93, 39, 41, 10, 105, 102, 40, 105, 116, 101, 109, 115, 46, 108, 101, 110, 103, 116, 104, 61, 61, 49, 41, 123, 118, 97, 114, 32, 105, 116, 101, 109, 61, 105, 116, 101, 109, 115, 91, 48, 93, 59, 105, 116, 101, 109, 46, 99, 108, 97, 115, 115, 76, 105, 115, 116, 46, 97, 100, 100, 40, 39, 114, 101, 100, 45, 98, 111, 114, 100, 101, 114, 39, 41, 59, 95, 46, 115, 99, 114, 111, 108, 108, 84, 111, 40, 105, 116, 101, 109, 41, 59, 125, 125, 10, 102, 117, 110, 99, 116, 105, 111, 110, 32, 115, 101, 116, 117, 112, 71, 111, 84, 111, 40, 41, 123, 118, 97, 114, 32, 110, 108, 61, 100, 111, 99, 117, 109, 101, 110, 116, 46, 113, 117, 101, 114, 121, 83, 101, 108, 101, 99, 116, 111, 114, 65, 108, 108, 40, 39, 91, 100, 97, 116, 97, 45, 103, 111, 116, 111, 93, 39, 41, 59, 102, 111, 114, 40, 118, 97, 114, 32, 105, 61, 48, 59, 105, 60, 110, 108, 46, 108, 101, 110, 103, 116, 104, 59, 43, 43, 105, 41, 123, 118, 97, 114, 32, 105, 116, 101, 109, 61, 110, 108, 91, 105, 93, 59, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 40, 105, 116, 101, 109, 41, 59, 105, 116, 101, 109, 46, 111, 110, 99, 108, 105, 99, 107, 61, 102, 117, 110, 99, 116, 105, 111, 110, 40, 41, 123, 105, 116, 101, 109, 61, 116, 104, 105, 115, 59, 118, 97, 114, 32, 118, 97, 108, 61, 105, 116, 101, 109, 46, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 46, 103, 101, 116, 78, 97, 109, 101, 100, 73, 116, 101, 109, 40, 39, 100, 97, 116, 97, 45, 103, 111, 116, 111, 39, 41, 46, 118, 97, 108, 117, 101, 59, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 40, 39, 102, 105, 110, 100, 32, 39, 43, 118, 97, 108, 41, 59, 104, 105, 103, 104, 108, 105, 103, 104, 116, 73, 100, 40, 118, 97, 108, 41, 59, 125, 125, 125, 10, 102, 117, 110, 99, 116, 105, 111, 110, 32, 115, 101, 116, 117, 112, 84, 111, 103, 103, 108, 101, 40, 41, 123, 95, 46, 102, 111, 114, 101, 97, 99, 104, 83, 101, 108, 101, 99, 116, 111, 114, 40, 39, 46, 116, 103, 39, 44, 102, 117, 110, 99, 116, 105, 111, 110, 40, 101, 41, 123, 118, 97, 114, 32, 115, 112, 97, 110, 61, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 39, 115, 112, 97, 110, 39, 41, 59, 115, 112, 97, 110, 46, 116, 111, 103, 103, 108, 101, 61, 101, 59, 115, 112, 97, 110, 46, 99, 108, 97, 115, 115, 76, 105, 115, 116, 46, 97, 100, 100, 40, 39, 101, 120, 112, 97, 110, 100, 116, 101, 120, 116, 39, 41, 10, 115, 112, 97, 110, 46, 105, 110, 110, 101, 114, 84, 101, 120, 116, 61, 34, 46, 46, 46, 34, 59, 115, 112, 97, 110, 46, 111, 110, 99, 108, 105, 99, 107, 61, 102, 117, 110, 99, 116, 105, 111, 110, 40, 41, 123, 116, 104, 105, 115, 46, 116, 111, 103, 103, 108, 101, 46, 99, 108, 97, 115, 115, 76, 105, 115, 116, 46, 116, 111, 103, 103, 108, 101, 40, 39, 104, 39, 41, 59, 95, 46, 114, 101, 109, 111, 118, 101, 69, 108, 101, 109, 101, 110, 116, 40, 116, 104, 105, 115, 41, 59, 125, 59, 101, 46, 112, 97, 114, 101, 110, 116, 69, 108, 101, 109, 101, 110, 116, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 115, 112, 97, 110, 41, 59, 101, 46, 99, 108, 97, 115, 115, 76, 105, 115, 116, 46, 116, 111, 103, 103, 108, 101, 40, 39, 104, 39, 41, 59, 125, 41, 59, 125, 10, 102, 117, 110, 99, 116, 105, 111, 110, 32, 109, 97, 105, 110, 40, 41, 123, 115, 101, 116, 117, 112, 71, 111, 84, 111, 40, 41, 59, 115, 101, 116, 117, 112, 84, 111, 103, 103, 108, 101, 40, 41, 59, 125, 10, 109, 97, 105, 110, 40, 41, 59, };
        public static byte[] Style = new byte[] { 98, 111, 100, 121, 123, 109, 97, 114, 103, 105, 110, 58, 32, 48, 46, 51, 101, 109, 32, 48, 46, 51, 101, 109, 32, 48, 46, 52, 101, 109, 32, 48, 46, 52, 101, 109, 59, 32, 102, 111, 110, 116, 45, 102, 97, 109, 105, 108, 121, 58, 32, 86, 101, 114, 100, 97, 110, 97, 59, 32, 102, 111, 110, 116, 45, 115, 105, 122, 101, 58, 32, 55, 53, 37, 59, 32, 98, 97, 99, 107, 103, 114, 111, 117, 110, 100, 58, 32, 119, 104, 105, 116, 101, 59, 125, 116, 97, 98, 108, 101, 123, 98, 111, 114, 100, 101, 114, 45, 99, 111, 108, 108, 97, 112, 115, 101, 58, 32, 99, 111, 108, 108, 97, 112, 115, 101, 59, 32, 98, 111, 114, 100, 101, 114, 58, 32, 49, 112, 120, 32, 115, 111, 108, 105, 100, 32, 35, 49, 55, 98, 59, 32, 109, 97, 114, 103, 105, 110, 58, 32, 48, 46, 51, 101, 109, 32, 48, 46, 50, 101, 109, 59, 125, 116, 100, 44, 32, 116, 104, 123, 118, 101, 114, 116, 105, 99, 97, 108, 45, 97, 108, 105, 103, 110, 58, 32, 116, 111, 112, 59, 32, 98, 111, 114, 100, 101, 114, 58, 32, 49, 112, 120, 32, 115, 111, 108, 105, 100, 32, 35, 97, 97, 97, 59, 32, 112, 97, 100, 100, 105, 110, 103, 58, 32, 48, 46, 49, 101, 109, 32, 48, 46, 50, 101, 109, 59, 32, 109, 97, 114, 103, 105, 110, 58, 32, 48, 59, 125, 116, 104, 123, 116, 101, 120, 116, 45, 97, 108, 105, 103, 110, 58, 32, 108, 101, 102, 116, 59, 32, 98, 97, 99, 107, 103, 114, 111, 117, 110, 100, 45, 99, 111, 108, 111, 114, 58, 32, 35, 100, 100, 100, 59, 32, 98, 111, 114, 100, 101, 114, 58, 32, 49, 112, 120, 32, 115, 111, 108, 105, 100, 32, 35, 55, 55, 55, 59, 32, 102, 111, 110, 116, 45, 102, 97, 109, 105, 108, 121, 58, 32, 116, 97, 104, 111, 109, 97, 59, 32, 102, 111, 110, 116, 45, 115, 105, 122, 101, 58, 32, 57, 48, 37, 59, 32, 102, 111, 110, 116, 45, 119, 101, 105, 103, 104, 116, 58, 32, 98, 111, 108, 100, 59, 125, 32, 116, 104, 46, 111, 123, 32, 98, 97, 99, 107, 103, 114, 111, 117, 110, 100, 45, 99, 111, 108, 111, 114, 58, 32, 35, 98, 98, 98, 59, 125, 32, 116, 104, 46, 111, 32, 46, 116, 121, 112, 101, 123, 32, 32, 99, 111, 108, 111, 114, 58, 32, 116, 101, 97, 108, 59, 32, 32, 125, 46, 103, 111, 116, 111, 44, 32, 46, 101, 120, 112, 97, 110, 100, 116, 101, 120, 116, 123, 98, 97, 99, 107, 103, 114, 111, 117, 110, 100, 58, 32, 103, 114, 101, 101, 110, 59, 32, 99, 117, 114, 115, 111, 114, 58, 32, 112, 111, 105, 110, 116, 101, 114, 59, 125, 46, 114, 101, 100, 45, 98, 111, 114, 100, 101, 114, 123, 98, 111, 114, 100, 101, 114, 58, 32, 115, 111, 108, 105, 100, 32, 51, 112, 120, 32, 114, 101, 100, 59, 125, 105, 123, 99, 111, 108, 111, 114, 58, 32, 103, 114, 101, 101, 110, 59, 125, 101, 109, 123, 99, 111, 108, 111, 114, 58, 32, 114, 101, 100, 59, 125, 46, 104, 123, 100, 105, 115, 112, 108, 97, 121, 58, 32, 110, 111, 110, 101, 32, 33, 105, 109, 112, 111, 114, 116, 97, 110, 116, 59, 125, 47, 42, 46, 115, 123, 100, 105, 115, 112, 108, 97, 121, 58, 32, 98, 108, 111, 99, 107, 59, 125, 42, 47, 115, 112, 97, 110, 46, 98, 123, 99, 111, 108, 111, 114, 58, 32, 98, 108, 117, 101, 59, 32, 102, 111, 110, 116, 45, 102, 97, 109, 105, 108, 121, 58, 32, 67, 111, 110, 115, 111, 108, 97, 115, 44, 32, 109, 111, 110, 111, 115, 112, 97, 99, 101, 59, 125, 107, 98, 100, 123, 47, 42, 32, 69, 110, 117, 109, 32, 42, 47, 32, 98, 97, 99, 107, 103, 114, 111, 117, 110, 100, 58, 32, 98, 108, 97, 99, 107, 59, 32, 99, 111, 108, 111, 114, 58, 32, 119, 104, 105, 116, 101, 59, 32, 112, 97, 100, 100, 105, 110, 103, 45, 108, 101, 102, 116, 58, 52, 112, 120, 59, 32, 112, 97, 100, 100, 105, 110, 103, 45, 114, 105, 103, 104, 116, 58, 52, 112, 120, 59, 32, 98, 111, 114, 100, 101, 114, 45, 114, 97, 100, 105, 117, 115, 58, 52, 112, 120, 59, 125, };
    }
}

